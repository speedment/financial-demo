package com.extspeeder.example.financialdemo.db.prices.generated;

import com.extspeeder.example.financialdemo.db.prices.PriceStore;
import com.extspeeder.example.financialdemo.db.prices.PriceStoreEntityStoreSerializerImpl;
import com.extspeeder.example.financialdemo.db.prices.PriceStoreManager;
import com.speedment.enterprise.datastore.runtime.HasStatistics.Statistics;
import com.speedment.enterprise.datastore.runtime.entitystore.EntityStore;
import com.speedment.enterprise.datastore.runtime.entitystore.EntityStoreHolder;
import com.speedment.enterprise.datastore.runtime.entitystore.StringSelection.Encoding;
import com.speedment.enterprise.datastore.runtime.fieldcache.FieldCache.OfFloat;
import com.speedment.enterprise.datastore.runtime.fieldcache.FieldCache.OfInt;
import com.speedment.enterprise.datastore.runtime.fieldcache.FieldCache.OfLong;
import com.speedment.enterprise.datastore.runtime.fieldcache.FieldCache.OfString;
import com.speedment.enterprise.datastore.runtime.fieldcache.FieldCache;
import com.speedment.enterprise.datastore.runtime.fieldcache.FieldCacheBuilder;
import com.speedment.enterprise.datastore.runtime.internal.util.StatisticsInternalUtil;
import com.speedment.enterprise.datastore.runtime.util.DataStoreHolderUtil;
import com.speedment.runtime.config.identifier.ColumnIdentifier;
import com.speedment.runtime.config.identifier.TableIdentifier;
import com.speedment.runtime.core.component.StreamSupplierComponent;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import javax.annotation.Generated;
import static java.util.Objects.requireNonNull;

/**
 * A holder class for the various caches that are used to speed up the {@link
 * PriceStoreManager}.
 * <p>
 * This file has been automatically generated by Speedment. Any changes made to
 * it will be overwritten.
 * 
 * @author Speedment
 */
@Generated("Speedment")
public final class GeneratedPriceStoreCacheHolder implements EntityStoreHolder<PriceStore> {
    
    private final static TableIdentifier<PriceStore> TABLE_IDENTIFIER = TableIdentifier.of("db0", "piq", "price_store");
    private final EntityStore<PriceStore> entityStore;
    private final OfLong<PriceStore> fieldIdCache;
    private final OfInt<PriceStore> fieldValueDateCache;
    private final OfFloat<PriceStore> fieldOpenCache;
    private final OfFloat<PriceStore> fieldHighCache;
    private final OfFloat<PriceStore> fieldLowCache;
    private final OfFloat<PriceStore> fieldCloseCache;
    private final OfString<PriceStore> fieldInstrumentSymbolCache;
    
    public GeneratedPriceStoreCacheHolder(
            EntityStore<PriceStore> entityStore,
            OfLong<PriceStore> fieldIdCache,
            OfInt<PriceStore> fieldValueDateCache,
            OfFloat<PriceStore> fieldOpenCache,
            OfFloat<PriceStore> fieldHighCache,
            OfFloat<PriceStore> fieldLowCache,
            OfFloat<PriceStore> fieldCloseCache,
            OfString<PriceStore> fieldInstrumentSymbolCache) {
        
        this.entityStore                = requireNonNull(entityStore);
        this.fieldIdCache               = requireNonNull(fieldIdCache);
        this.fieldValueDateCache        = requireNonNull(fieldValueDateCache);
        this.fieldOpenCache             = requireNonNull(fieldOpenCache);
        this.fieldHighCache             = requireNonNull(fieldHighCache);
        this.fieldLowCache              = requireNonNull(fieldLowCache);
        this.fieldCloseCache            = requireNonNull(fieldCloseCache);
        this.fieldInstrumentSymbolCache = requireNonNull(fieldInstrumentSymbolCache);
    }
    
    @Override
    public EntityStore<PriceStore> getEntityStore() {
        return entityStore;
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public <ENTITY, T> FieldCache<ENTITY, T> getFieldCache(ColumnIdentifier<ENTITY> columnId) {
        if (columnId instanceof PriceStore.Identifier) {
            final PriceStore.Identifier _id = (PriceStore.Identifier) columnId;
            switch (_id) {
                case ID                : return (FieldCache<ENTITY, T>) fieldIdCache;
                case VALUE_DATE        : return (FieldCache<ENTITY, T>) fieldValueDateCache;
                case OPEN              : return (FieldCache<ENTITY, T>) fieldOpenCache;
                case HIGH              : return (FieldCache<ENTITY, T>) fieldHighCache;
                case LOW               : return (FieldCache<ENTITY, T>) fieldLowCache;
                case CLOSE             : return (FieldCache<ENTITY, T>) fieldCloseCache;
                case INSTRUMENT_SYMBOL : return (FieldCache<ENTITY, T>) fieldInstrumentSymbolCache;
                default : throw new UnsupportedOperationException(
                    String.format("Unknown enum constant '%s'.", _id)
                );
            }
        } else {
            final String _colName = columnId.getColumnName();
            switch (_colName) {
                case "id"                : return (FieldCache<ENTITY, T>) fieldIdCache;
                case "value_date"        : return (FieldCache<ENTITY, T>) fieldValueDateCache;
                case "open"              : return (FieldCache<ENTITY, T>) fieldOpenCache;
                case "high"              : return (FieldCache<ENTITY, T>) fieldHighCache;
                case "low"               : return (FieldCache<ENTITY, T>) fieldLowCache;
                case "close"             : return (FieldCache<ENTITY, T>) fieldCloseCache;
                case "instrument_symbol" : return (FieldCache<ENTITY, T>) fieldInstrumentSymbolCache;
                default : throw new UnsupportedOperationException(
                    String.format("Unknown column name '%s'.", _colName)
                );
            }
        }
    }
    
    public static CompletableFuture<GeneratedPriceStoreCacheHolder> reload(StreamSupplierComponent streamSupplier, ExecutorService executor) {
        final PriceStoreEntityStoreSerializerImpl serializer = 
            new PriceStoreEntityStoreSerializerImpl();
        final CompletableFuture<EntityStore<PriceStore>> entityStoreFuture = 
            DataStoreHolderUtil.buildEntityStore(streamSupplier, executor, serializer, TABLE_IDENTIFIER);
        
        final CompletableFuture<FieldCache.OfLong<PriceStore>> fieldIdCacheFuture =
            DataStoreHolderUtil.buildLongCache(entityStoreFuture, executor, PriceStore.ID, FieldCache.UNINDEXED | FieldCache.REFERENCE_ORDER);
        
        final CompletableFuture<FieldCache.OfInt<PriceStore>> fieldValueDateCacheFuture =
            DataStoreHolderUtil.buildIntCache(entityStoreFuture, executor, PriceStore.VALUE_DATE, 0);
        
        final CompletableFuture<FieldCache.OfFloat<PriceStore>> fieldOpenCacheFuture =
            DataStoreHolderUtil.buildFloatCache(entityStoreFuture, executor, PriceStore.OPEN, FieldCache.UNINDEXED);
        
        final CompletableFuture<FieldCache.OfFloat<PriceStore>> fieldHighCacheFuture =
            DataStoreHolderUtil.buildFloatCache(entityStoreFuture, executor, PriceStore.HIGH, FieldCache.UNINDEXED);
        
        final CompletableFuture<FieldCache.OfFloat<PriceStore>> fieldLowCacheFuture =
            DataStoreHolderUtil.buildFloatCache(entityStoreFuture, executor, PriceStore.LOW, FieldCache.UNINDEXED);
        
        final CompletableFuture<FieldCache.OfFloat<PriceStore>> fieldCloseCacheFuture =
            DataStoreHolderUtil.buildFloatCache(entityStoreFuture, executor, PriceStore.CLOSE, FieldCache.UNINDEXED);
        
        final CompletableFuture<FieldCache.OfString<PriceStore>> fieldInstrumentSymbolCacheFuture =
            DataStoreHolderUtil.buildStringCache(entityStoreFuture, executor, PriceStore.INSTRUMENT_SYMBOL, 0, Encoding.UTF_8);
        
        return entityStoreFuture.thenApplyAsync(entityStore -> {
            try {
                return new GeneratedPriceStoreCacheHolder(
                    entityStore,
                    fieldIdCacheFuture.get(),
                    fieldValueDateCacheFuture.get(),
                    fieldOpenCacheFuture.get(),
                    fieldHighCacheFuture.get(),
                    fieldLowCacheFuture.get(),
                    fieldCloseCacheFuture.get(),
                    fieldInstrumentSymbolCacheFuture.get()
                );
            } catch (final ExecutionException | InterruptedException ex) {
                throw new RuntimeException(ex);
            }
        });
    }
    
    @Override
    public void close() {
        entityStore.close();
        fieldIdCache.close();
        fieldValueDateCache.close();
        fieldOpenCache.close();
        fieldHighCache.close();
        fieldLowCache.close();
        fieldCloseCache.close();
        fieldInstrumentSymbolCache.close();
    }
    
    @Override
    public Map<String, Map<Statistics, ?>> getStatistics() {
        return StatisticsInternalUtil.getStatistics(    
            this,
            TABLE_IDENTIFIER,
            PriceStore.Identifier.ID,
            PriceStore.Identifier.VALUE_DATE,
            PriceStore.Identifier.OPEN,
            PriceStore.Identifier.HIGH,
            PriceStore.Identifier.LOW,
            PriceStore.Identifier.CLOSE,
            PriceStore.Identifier.INSTRUMENT_SYMBOL
        );
    }
}