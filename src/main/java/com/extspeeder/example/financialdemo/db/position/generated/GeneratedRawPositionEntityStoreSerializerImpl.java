package com.extspeeder.example.financialdemo.db.position.generated;

import com.extspeeder.example.financialdemo.db.position.RawPosition;
import com.extspeeder.example.financialdemo.db.position.RawPositionImpl;
import com.speedment.enterprise.datastore.runtime.entitystore.EntityStoreSerializer;
import com.speedment.enterprise.datastore.runtime.entitystore.StringSelection;
import com.speedment.enterprise.datastore.runtime.util.SerializerUtil;
import com.speedment.runtime.config.identifier.ColumnIdentifier;
import com.speedment.runtime.core.util.OptionalUtil;
import com.speedment.runtime.field.Field;
import com.speedment.runtime.field.StringField;
import com.speedment.runtime.field.trait.HasBooleanValue;
import com.speedment.runtime.field.trait.HasByteValue;
import com.speedment.runtime.field.trait.HasCharValue;
import com.speedment.runtime.field.trait.HasDoubleValue;
import com.speedment.runtime.field.trait.HasFloatValue;
import com.speedment.runtime.field.trait.HasIntValue;
import com.speedment.runtime.field.trait.HasLongValue;
import com.speedment.runtime.field.trait.HasReferenceValue;
import com.speedment.runtime.field.trait.HasShortValue;
import java.math.BigDecimal;
import java.nio.BufferOverflowException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import javax.annotation.Generated;

/**
 * Serializes and deserializes instances of RawPosition.
 * <p>
 * This file has been automatically generated by Speedment. Any changes made to
 * it will be overwritten.
 * <p>
 * The layout of the ByteBuffer:
 * <pre>
 * +--------+--------+------+--------------------+--------+------------------+
 * | Begin  | End    | Len  |               Name |  Usage |             Type |
 * +--------+--------+------+--------------------+--------+------------------+
 * |                      Constant Non-Nullable Fields                       |
 * +--------+--------+------+--------------------+--------+------------------+
 * | 0x0000 | 0x0007 | 0x08 |                 id |   data |             long |
 * | 0x0008 | 0x000B | 0x04 |                pnl |   data |            float |
 * | 0x000C | 0x000F | 0x04 | total_initiate_mkt_val |   data |            float
 * |
 * | 0x0010 | 0x0013 | 0x04 | total_liquidate_mkt_val |   data |           
 * float |
 * | 0x0014 | 0x0017 | 0x04 |     value_date_int |   data |              int |
 * +--------+--------+------+--------------------+--------+------------------+
 * |                              End Positions                              |
 * +--------+--------+------+--------------------+--------+------------------+
 * | 0x0018 | 0x001B | 0x04 |        trader_name | endpos |           String |
 * | 0x001C | 0x001F | 0x04 |       trader_group | endpos |           String |
 * | 0x0020 | 0x0023 | 0x04 |  trader_group_type | endpos |           String |
 * | 0x0024 | 0x0027 | 0x04 |    instrument_name | endpos |           String |
 * | 0x0028 | 0x002B | 0x04 |  instrument_symbol | endpos |           String |
 * | 0x002C | 0x002F | 0x04 |  instrument_sector | endpos |           String |
 * | 0x0030 | 0x0033 | 0x04 | instrument_industry | endpos |           String |
 * +--------+--------+------+--------------------+--------+------------------+
 * |                               Row Storage                               |
 * +--------+--------+------+--------------------+--------+------------------+
 * |                 Constant Nullables and Variable Fields                  |
 * +--------+--------+------+--------------------+--------+------------------+
 * | 0x0034 | 0x7FFE | 0x00 | Variable data area |   data |           byte[] |
 * +--------+--------+------+--------------------+--------+------------------+
 * </pre>
 * <p>
 * Variable data area layout order:
 * traderName, traderGroup, traderGroupType, instrumentName, instrumentSymbol,
 * instrumentSector, instrumentIndustry
 * 
 * @author Speedment
 */
@Generated("Speedment")
public class GeneratedRawPositionEntityStoreSerializerImpl implements EntityStoreSerializer<RawPosition> {
    
    /**
     * Serializes and writes the id of the daily_position_performance to the
     * specified buffer.
     * 
     * @param out       the byte buffer to write to
     * @param rowOffset index where the row should start
     * @param value     value to serialize and write
     */
    protected void serializeId(ByteBuffer out, int rowOffset, long value) {
        out.putLong(0 + rowOffset, value);
    }
    
    /**
     * Returns the id of the daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the value starts
     * @return          the deserialized value
     */
    protected long deserializeId(ByteBuffer in, int rowOffset) {
        return in.getLong(0 + rowOffset);
    }
    
    /**
     * Serializes and writes the pnl of the daily_position_performance to the
     * specified buffer.
     * 
     * @param out       the byte buffer to write to
     * @param rowOffset index where the row should start
     * @param value     value to serialize and write
     */
    protected void serializePnl(ByteBuffer out, int rowOffset, float value) {
        out.putFloat(8 + rowOffset, value);
    }
    
    /**
     * Returns the pnl of the daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the value starts
     * @return          the deserialized value
     */
    protected float deserializePnl(ByteBuffer in, int rowOffset) {
        return in.getFloat(8 + rowOffset);
    }
    
    /**
     * Serializes and writes the total_initiate_mkt_val of the
     * daily_position_performance to the specified buffer.
     * 
     * @param out       the byte buffer to write to
     * @param rowOffset index where the row should start
     * @param value     value to serialize and write
     */
    protected void serializeInitiateTradingMktVal(ByteBuffer out, int rowOffset, float value) {
        out.putFloat(12 + rowOffset, value);
    }
    
    /**
     * Returns the total_initiate_mkt_val of the daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the value starts
     * @return          the deserialized value
     */
    protected float deserializeInitiateTradingMktVal(ByteBuffer in, int rowOffset) {
        return in.getFloat(12 + rowOffset);
    }
    
    /**
     * Serializes and writes the total_liquidate_mkt_val of the
     * daily_position_performance to the specified buffer.
     * 
     * @param out       the byte buffer to write to
     * @param rowOffset index where the row should start
     * @param value     value to serialize and write
     */
    protected void serializeLiquidateTradingMktVal(ByteBuffer out, int rowOffset, float value) {
        out.putFloat(16 + rowOffset, value);
    }
    
    /**
     * Returns the total_liquidate_mkt_val of the daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the value starts
     * @return          the deserialized value
     */
    protected float deserializeLiquidateTradingMktVal(ByteBuffer in, int rowOffset) {
        return in.getFloat(16 + rowOffset);
    }
    
    /**
     * Serializes and writes the value_date_int of the
     * daily_position_performance to the specified buffer.
     * 
     * @param out       the byte buffer to write to
     * @param rowOffset index where the row should start
     * @param value     value to serialize and write
     */
    protected void serializeValueDate(ByteBuffer out, int rowOffset, int value) {
        out.putInt(20 + rowOffset, value);
    }
    
    /**
     * Returns the value_date_int of the daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the value starts
     * @return          the deserialized value
     */
    protected int deserializeValueDate(ByteBuffer in, int rowOffset) {
        return in.getInt(20 + rowOffset);
    }
    
    /**
     * Serializes and writes the trader_name of the daily_position_performance
     * to the specified buffer, returning the index of the next value.
     * 
     * @param out          the byte buffer to write to
     * @param rowOffset    index in buffer where the row starts
     * @param begin        offset to the position for the particular column
     * @param endPosOffset offset to the position for the end index
     * @param value        the value to serialize
     * @return             last index of the string (exclusive)
     */
    protected int serializeTraderName(
            ByteBuffer out,
            int rowOffset,
            int begin,
            int endPosOffset,
            String value) {
        return SerializerUtil.serializeByteArrayPutInt(out, rowOffset, begin, value.getBytes(StandardCharsets.UTF_8), endPosOffset);
    }
    
    /**
     * Returns the trader_name of the daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected String deserializeTraderName(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        return selectStringTraderName(in, rowOffset, begin, end)
            .toString(StringSelection.Encoding.UTF_8);
    }
    
    /**
     * Serializes and writes the trader_group of the daily_position_performance
     * to the specified buffer, returning the index of the next value.
     * 
     * @param out          the byte buffer to write to
     * @param rowOffset    index in buffer where the row starts
     * @param begin        offset to the position for the particular column
     * @param endPosOffset offset to the position for the end index
     * @param value        the value to serialize
     * @return             last index of the string (exclusive)
     */
    protected int serializeTraderGroup(
            ByteBuffer out,
            int rowOffset,
            int begin,
            int endPosOffset,
            String value) {
        return SerializerUtil.serializeByteArrayPutInt(out, rowOffset, begin, value.getBytes(StandardCharsets.UTF_8), endPosOffset);
    }
    
    /**
     * Returns the trader_group of the daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected String deserializeTraderGroup(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        return selectStringTraderGroup(in, rowOffset, begin, end)
            .toString(StringSelection.Encoding.UTF_8);
    }
    
    /**
     * Serializes and writes the trader_group_type of the
     * daily_position_performance to the specified buffer, returning the index
     * of the next value.
     * 
     * @param out          the byte buffer to write to
     * @param rowOffset    index in buffer where the row starts
     * @param begin        offset to the position for the particular column
     * @param endPosOffset offset to the position for the end index
     * @param value        the value to serialize
     * @return             last index of the string (exclusive)
     */
    protected int serializeTraderGroupType(
            ByteBuffer out,
            int rowOffset,
            int begin,
            int endPosOffset,
            String value) {
        return SerializerUtil.serializeByteArrayPutInt(out, rowOffset, begin, value.getBytes(StandardCharsets.UTF_8), endPosOffset);
    }
    
    /**
     * Returns the trader_group_type of the daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected String deserializeTraderGroupType(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        return selectStringTraderGroupType(in, rowOffset, begin, end)
            .toString(StringSelection.Encoding.UTF_8);
    }
    
    /**
     * Serializes and writes the instrument_name of the
     * daily_position_performance to the specified buffer, returning the index
     * of the next value.
     * 
     * @param out          the byte buffer to write to
     * @param rowOffset    index in buffer where the row starts
     * @param begin        offset to the position for the particular column
     * @param endPosOffset offset to the position for the end index
     * @param value        the value to serialize
     * @return             last index of the string (exclusive)
     */
    protected int serializeInstrumentName(
            ByteBuffer out,
            int rowOffset,
            int begin,
            int endPosOffset,
            String value) {
        return SerializerUtil.serializeByteArrayPutInt(out, rowOffset, begin, value == null ? null : value.getBytes(StandardCharsets.UTF_8), endPosOffset);
    }
    
    /**
     * Returns the instrument_name of the daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected String deserializeInstrumentName(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        if (end < 0) {
            return null;
        } else {
            return selectStringInstrumentName(in, rowOffset, begin, end)
                .toString(StringSelection.Encoding.UTF_8);
        }
    }
    
    /**
     * Serializes and writes the instrument_symbol of the
     * daily_position_performance to the specified buffer, returning the index
     * of the next value.
     * 
     * @param out          the byte buffer to write to
     * @param rowOffset    index in buffer where the row starts
     * @param begin        offset to the position for the particular column
     * @param endPosOffset offset to the position for the end index
     * @param value        the value to serialize
     * @return             last index of the string (exclusive)
     */
    protected int serializeInstrumentSymbol(
            ByteBuffer out,
            int rowOffset,
            int begin,
            int endPosOffset,
            String value) {
        return SerializerUtil.serializeByteArrayPutInt(out, rowOffset, begin, value.getBytes(StandardCharsets.UTF_8), endPosOffset);
    }
    
    /**
     * Returns the instrument_symbol of the daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected String deserializeInstrumentSymbol(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        return selectStringInstrumentSymbol(in, rowOffset, begin, end)
            .toString(StringSelection.Encoding.UTF_8);
    }
    
    /**
     * Serializes and writes the instrument_sector of the
     * daily_position_performance to the specified buffer, returning the index
     * of the next value.
     * 
     * @param out          the byte buffer to write to
     * @param rowOffset    index in buffer where the row starts
     * @param begin        offset to the position for the particular column
     * @param endPosOffset offset to the position for the end index
     * @param value        the value to serialize
     * @return             last index of the string (exclusive)
     */
    protected int serializeInstrumentSector(
            ByteBuffer out,
            int rowOffset,
            int begin,
            int endPosOffset,
            String value) {
        return SerializerUtil.serializeByteArrayPutInt(out, rowOffset, begin, value == null ? null : value.getBytes(StandardCharsets.UTF_8), endPosOffset);
    }
    
    /**
     * Returns the instrument_sector of the daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected String deserializeInstrumentSector(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        if (end < 0) {
            return null;
        } else {
            return selectStringInstrumentSector(in, rowOffset, begin, end)
                .toString(StringSelection.Encoding.UTF_8);
        }
    }
    
    /**
     * Serializes and writes the instrument_industry of the
     * daily_position_performance to the specified buffer, returning the index
     * of the next value.
     * 
     * @param out          the byte buffer to write to
     * @param rowOffset    index in buffer where the row starts
     * @param begin        offset to the position for the particular column
     * @param endPosOffset offset to the position for the end index
     * @param value        the value to serialize
     * @return             last index of the string (exclusive)
     */
    protected int serializeInstrumentIndustry(
            ByteBuffer out,
            int rowOffset,
            int begin,
            int endPosOffset,
            String value) {
        return SerializerUtil.serializeByteArrayPutInt(out, rowOffset, begin, value == null ? null : value.getBytes(StandardCharsets.UTF_8), endPosOffset);
    }
    
    /**
     * Returns the instrument_industry of the daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected String deserializeInstrumentIndustry(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        if (end < 0) {
            return null;
        } else {
            return selectStringInstrumentIndustry(in, rowOffset, begin, end)
                .toString(StringSelection.Encoding.UTF_8);
        }
    }
    
    @Override
    public StringSelection selectString(ByteBuffer in, int rowOffset, StringField<RawPosition, ?> field) {
        final ColumnIdentifier<RawPosition> colId = field.identifier();
        if (colId instanceof RawPosition.Identifier) {
            final RawPosition.Identifier _id = (RawPosition.Identifier) colId;
            switch (_id) {
                case TRADER_NAME         : return selectStringTraderName(in,           rowOffset, 52,                                  in.getInt(rowOffset + 24));
                case TRADER_GROUP        : return selectStringTraderGroup(in,          rowOffset, Math.abs(in.getInt(rowOffset + 24)), in.getInt(rowOffset + 28));
                case TRADER_GROUP_TYPE   : return selectStringTraderGroupType(in,      rowOffset, Math.abs(in.getInt(rowOffset + 28)), in.getInt(rowOffset + 32));
                case INSTRUMENT_NAME     : return selectStringInstrumentName(in,       rowOffset, Math.abs(in.getInt(rowOffset + 32)), in.getInt(rowOffset + 36));
                case INSTRUMENT_SYMBOL   : return selectStringInstrumentSymbol(in,     rowOffset, Math.abs(in.getInt(rowOffset + 36)), in.getInt(rowOffset + 40));
                case INSTRUMENT_SECTOR   : return selectStringInstrumentSector(in,     rowOffset, Math.abs(in.getInt(rowOffset + 40)), in.getInt(rowOffset + 44));
                case INSTRUMENT_INDUSTRY : return selectStringInstrumentIndustry(in,   rowOffset, Math.abs(in.getInt(rowOffset + 44)), in.getInt(rowOffset + 48));
                default : throw new UnsupportedOperationException(
                    String.format("Unknown enum constant '%s'.", _id)
                );
            }
        } else {
            final String _colName = colId.getColumnName();
            switch (_colName) {
                case "trader_name"         : return selectStringTraderName(in,         rowOffset, 52,                                  in.getInt(rowOffset + 24));
                case "trader_group"        : return selectStringTraderGroup(in,        rowOffset, Math.abs(in.getInt(rowOffset + 24)), in.getInt(rowOffset + 28));
                case "trader_group_type"   : return selectStringTraderGroupType(in,    rowOffset, Math.abs(in.getInt(rowOffset + 28)), in.getInt(rowOffset + 32));
                case "instrument_name"     : return selectStringInstrumentName(in,     rowOffset, Math.abs(in.getInt(rowOffset + 32)), in.getInt(rowOffset + 36));
                case "instrument_symbol"   : return selectStringInstrumentSymbol(in,   rowOffset, Math.abs(in.getInt(rowOffset + 36)), in.getInt(rowOffset + 40));
                case "instrument_sector"   : return selectStringInstrumentSector(in,   rowOffset, Math.abs(in.getInt(rowOffset + 40)), in.getInt(rowOffset + 44));
                case "instrument_industry" : return selectStringInstrumentIndustry(in, rowOffset, Math.abs(in.getInt(rowOffset + 44)), in.getInt(rowOffset + 48));
                default : throw new UnsupportedOperationException(
                    String.format("Unknown column name '%s'.", _colName)
                );
            }
        }
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public <T> T deserializeReference(ByteBuffer in, int rowOffset, HasReferenceValue<RawPosition, ?, T> field) {
        final ColumnIdentifier<RawPosition> colId = field.identifier();
        if (colId instanceof RawPosition.Identifier) {
            final RawPosition.Identifier _id = (RawPosition.Identifier) colId;
            switch (_id) {
                case TRADER_NAME         : return (T) deserializeTraderName(in,           rowOffset, 52,                                  in.getInt(rowOffset + 24));
                case TRADER_GROUP        : return (T) deserializeTraderGroup(in,          rowOffset, Math.abs(in.getInt(rowOffset + 24)), in.getInt(rowOffset + 28));
                case TRADER_GROUP_TYPE   : return (T) deserializeTraderGroupType(in,      rowOffset, Math.abs(in.getInt(rowOffset + 28)), in.getInt(rowOffset + 32));
                case INSTRUMENT_NAME     : return (T) deserializeInstrumentName(in,       rowOffset, Math.abs(in.getInt(rowOffset + 32)), in.getInt(rowOffset + 36));
                case INSTRUMENT_SYMBOL   : return (T) deserializeInstrumentSymbol(in,     rowOffset, Math.abs(in.getInt(rowOffset + 36)), in.getInt(rowOffset + 40));
                case INSTRUMENT_SECTOR   : return (T) deserializeInstrumentSector(in,     rowOffset, Math.abs(in.getInt(rowOffset + 40)), in.getInt(rowOffset + 44));
                case INSTRUMENT_INDUSTRY : return (T) deserializeInstrumentIndustry(in,   rowOffset, Math.abs(in.getInt(rowOffset + 44)), in.getInt(rowOffset + 48));
                default : throw new UnsupportedOperationException(
                    String.format("Unknown enum constant '%s'.", _id)
                );
            }
        } else {
            final String _colName = colId.getColumnName();
            switch (_colName) {
                case "trader_name"         : return (T) deserializeTraderName(in,         rowOffset, 52,                                  in.getInt(rowOffset + 24));
                case "trader_group"        : return (T) deserializeTraderGroup(in,        rowOffset, Math.abs(in.getInt(rowOffset + 24)), in.getInt(rowOffset + 28));
                case "trader_group_type"   : return (T) deserializeTraderGroupType(in,    rowOffset, Math.abs(in.getInt(rowOffset + 28)), in.getInt(rowOffset + 32));
                case "instrument_name"     : return (T) deserializeInstrumentName(in,     rowOffset, Math.abs(in.getInt(rowOffset + 32)), in.getInt(rowOffset + 36));
                case "instrument_symbol"   : return (T) deserializeInstrumentSymbol(in,   rowOffset, Math.abs(in.getInt(rowOffset + 36)), in.getInt(rowOffset + 40));
                case "instrument_sector"   : return (T) deserializeInstrumentSector(in,   rowOffset, Math.abs(in.getInt(rowOffset + 40)), in.getInt(rowOffset + 44));
                case "instrument_industry" : return (T) deserializeInstrumentIndustry(in, rowOffset, Math.abs(in.getInt(rowOffset + 44)), in.getInt(rowOffset + 48));
                default : throw new UnsupportedOperationException(
                    String.format("Unknown column name '%s'.", _colName)
                );
            }
        }
    }
    
    @Override
    public boolean deserializeBoolean(ByteBuffer in, int rowOffset, HasBooleanValue<RawPosition, ?> field) {
        final ColumnIdentifier<RawPosition> colId = field.identifier();
        throw new UnsupportedOperationException(
            String.format("Unknown enum constant '%s'.", colId.getColumnName())
        );
    }
    
    @Override
    public byte deserializeByte(ByteBuffer in, int rowOffset, HasByteValue<RawPosition, ?> field) {
        final ColumnIdentifier<RawPosition> colId = field.identifier();
        throw new UnsupportedOperationException(
            String.format("Unknown enum constant '%s'.", colId.getColumnName())
        );
    }
    
    @Override
    public double deserializeDouble(ByteBuffer in, int rowOffset, HasDoubleValue<RawPosition, ?> field) {
        final ColumnIdentifier<RawPosition> colId = field.identifier();
        throw new UnsupportedOperationException(
            String.format("Unknown enum constant '%s'.", colId.getColumnName())
        );
    }
    
    @Override
    public char deserializeChar(ByteBuffer in, int rowOffset, HasCharValue<RawPosition, ?> field) {
        final ColumnIdentifier<RawPosition> colId = field.identifier();
        throw new UnsupportedOperationException(
            String.format("Unknown enum constant '%s'.", colId.getColumnName())
        );
    }
    
    @Override
    public short deserializeShort(ByteBuffer in, int rowOffset, HasShortValue<RawPosition, ?> field) {
        final ColumnIdentifier<RawPosition> colId = field.identifier();
        throw new UnsupportedOperationException(
            String.format("Unknown enum constant '%s'.", colId.getColumnName())
        );
    }
    
    @Override
    public float deserializeFloat(ByteBuffer in, int rowOffset, HasFloatValue<RawPosition, ?> field) {
        final ColumnIdentifier<RawPosition> colId = field.identifier();
        if (colId instanceof RawPosition.Identifier) {
            final RawPosition.Identifier _id = (RawPosition.Identifier) colId;
            switch (_id) {
                case PNL                       : return deserializePnl(in,                    rowOffset);
                case INITIATE_TRADING_MKT_VAL  : return deserializeInitiateTradingMktVal(in,  rowOffset);
                case LIQUIDATE_TRADING_MKT_VAL : return deserializeLiquidateTradingMktVal(in, rowOffset);
                default : throw new UnsupportedOperationException(
                    String.format("Unknown enum constant '%s'.", _id)
                );
            }
        } else {
            final String _colName = colId.getColumnName();
            switch (_colName) {
                case "pnl"                     : return deserializePnl(in,                    rowOffset);
                case "total_initiate_mkt_val"  : return deserializeInitiateTradingMktVal(in,  rowOffset);
                case "total_liquidate_mkt_val" : return deserializeLiquidateTradingMktVal(in, rowOffset);
                default : throw new UnsupportedOperationException(
                    String.format("Unknown column name '%s'.", _colName)
                );
            }
        }
    }
    
    @Override
    public int deserializeInt(ByteBuffer in, int rowOffset, HasIntValue<RawPosition, ?> field) {
        final ColumnIdentifier<RawPosition> colId = field.identifier();
        if ("value_date_int".equals(colId.getColumnName())) {
            return deserializeValueDate(in, rowOffset);
        }
        
        throw new UnsupportedOperationException(
            String.format("Unknown column '%s'.", colId)
        );
    }
    
    @Override
    public long deserializeLong(ByteBuffer in, int rowOffset, HasLongValue<RawPosition, ?> field) {
        final ColumnIdentifier<RawPosition> colId = field.identifier();
        if ("id".equals(colId.getColumnName())) {
            return deserializeId(in, rowOffset);
        }
        
        throw new UnsupportedOperationException(
            String.format("Unknown column '%s'.", colId)
        );
    }
    
    @Override
    public RawPosition deserialize(ByteBuffer in, int rowOffset) {
        final int traderNameEnd         = in.getInt(rowOffset + 24);
        final int traderGroupEnd        = in.getInt(rowOffset + 28);
        final int traderGroupTypeEnd    = in.getInt(rowOffset + 32);
        final int instrumentNameEnd     = in.getInt(rowOffset + 36);
        final int instrumentSymbolEnd   = in.getInt(rowOffset + 40);
        final int instrumentSectorEnd   = in.getInt(rowOffset + 44);
        final int instrumentIndustryEnd = in.getInt(rowOffset + 48);
        
        final RawPosition entity = newEntity();
        entity.setId(deserializeId(in, rowOffset));
        entity.setPnl(deserializePnl(in, rowOffset));
        entity.setInitiateTradingMktVal(deserializeInitiateTradingMktVal(in, rowOffset));
        entity.setLiquidateTradingMktVal(deserializeLiquidateTradingMktVal(in, rowOffset));
        entity.setValueDate(deserializeValueDate(in, rowOffset));
        entity.setTraderName(deserializeTraderName(in, rowOffset, 52, traderNameEnd));
        entity.setTraderGroup(deserializeTraderGroup(in, rowOffset, Math.abs(traderNameEnd), traderGroupEnd));
        entity.setTraderGroupType(deserializeTraderGroupType(in, rowOffset, Math.abs(traderGroupEnd), traderGroupTypeEnd));
        entity.setInstrumentName(deserializeInstrumentName(in, rowOffset, Math.abs(traderGroupTypeEnd), instrumentNameEnd));
        entity.setInstrumentSymbol(deserializeInstrumentSymbol(in, rowOffset, Math.abs(instrumentNameEnd), instrumentSymbolEnd));
        entity.setInstrumentSector(deserializeInstrumentSector(in, rowOffset, Math.abs(instrumentSymbolEnd), instrumentSectorEnd));
        entity.setInstrumentIndustry(deserializeInstrumentIndustry(in, rowOffset, Math.abs(instrumentSectorEnd), instrumentIndustryEnd));
        return entity;
    }
    
    @Override
    public int serialize(ByteBuffer out, int rowOffset, RawPosition entity) throws BufferOverflowException {
        int startPos = 52;
        
        serializeId(out, rowOffset, entity.getId());
        serializePnl(out, rowOffset, entity.getPnl());
        serializeInitiateTradingMktVal(out, rowOffset, entity.getInitiateTradingMktVal());
        serializeLiquidateTradingMktVal(out, rowOffset, entity.getLiquidateTradingMktVal());
        serializeValueDate(out, rowOffset, entity.getValueDate());
        startPos = serializeTraderName(out, rowOffset, startPos, 24, entity.getTraderName());
        startPos = serializeTraderGroup(out, rowOffset, startPos, 28, entity.getTraderGroup());
        startPos = serializeTraderGroupType(out, rowOffset, startPos, 32, entity.getTraderGroupType());
        startPos = serializeInstrumentName(out, rowOffset, startPos, 36, OptionalUtil.unwrap(entity.getInstrumentName()));
        startPos = serializeInstrumentSymbol(out, rowOffset, startPos, 40, entity.getInstrumentSymbol());
        startPos = serializeInstrumentSector(out, rowOffset, startPos, 44, OptionalUtil.unwrap(entity.getInstrumentSector()));
        startPos = serializeInstrumentIndustry(out, rowOffset, startPos, 48, OptionalUtil.unwrap(entity.getInstrumentIndustry()));
        return startPos;
    }
    
    protected RawPosition newEntity() {
        return new RawPositionImpl();
    }
    
    /**
     * Returns a selection of the trader_name of the daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected StringSelection selectStringTraderName(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        final int len = end - begin;
        return StringSelection.create(in, rowOffset + begin, len);
    }
    
    /**
     * Returns a selection of the trader_group of the
     * daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected StringSelection selectStringTraderGroup(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        final int len = end - begin;
        return StringSelection.create(in, rowOffset + begin, len);
    }
    
    /**
     * Returns a selection of the trader_group_type of the
     * daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected StringSelection selectStringTraderGroupType(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        final int len = end - begin;
        return StringSelection.create(in, rowOffset + begin, len);
    }
    
    /**
     * Returns a selection of the instrument_name of the
     * daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected StringSelection selectStringInstrumentName(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        final int len = end - begin;
        return StringSelection.create(in, rowOffset + begin, len);
    }
    
    /**
     * Returns a selection of the instrument_symbol of the
     * daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected StringSelection selectStringInstrumentSymbol(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        final int len = end - begin;
        return StringSelection.create(in, rowOffset + begin, len);
    }
    
    /**
     * Returns a selection of the instrument_sector of the
     * daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected StringSelection selectStringInstrumentSector(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        final int len = end - begin;
        return StringSelection.create(in, rowOffset + begin, len);
    }
    
    /**
     * Returns a selection of the instrument_industry of the
     * daily_position_performance.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected StringSelection selectStringInstrumentIndustry(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        final int len = end - begin;
        return StringSelection.create(in, rowOffset + begin, len);
    }
    
    @Override
    public boolean isNull(ByteBuffer in, int rowOffset, Field<RawPosition> field) {
        final ColumnIdentifier<RawPosition> colId = field.identifier();
        if (colId instanceof RawPosition.Identifier) {
            final RawPosition.Identifier _id = (RawPosition.Identifier) colId;
            switch (_id) {
                case ID                        : return false;
                case PNL                       : return false;
                case INITIATE_TRADING_MKT_VAL  : return false;
                case LIQUIDATE_TRADING_MKT_VAL : return false;
                case VALUE_DATE                : return false;
                case TRADER_NAME               : return false;
                case TRADER_GROUP              : return false;
                case TRADER_GROUP_TYPE         : return false;
                case INSTRUMENT_NAME           : return in.getInt(rowOffset + 36) < 0;
                case INSTRUMENT_SYMBOL         : return false;
                case INSTRUMENT_SECTOR         : return in.getInt(rowOffset + 44) < 0;
                case INSTRUMENT_INDUSTRY       : return in.getInt(rowOffset + 48) < 0;
                default : throw new UnsupportedOperationException(
                    String.format("Unknown enum constant '%s'.", _id)
                );
            }
        } else {
            final String _colName = colId.getColumnName();
            switch (_colName) {
                case "id"                      : return false;
                case "pnl"                     : return false;
                case "total_initiate_mkt_val"  : return false;
                case "total_liquidate_mkt_val" : return false;
                case "value_date_int"          : return false;
                case "trader_name"             : return false;
                case "trader_group"            : return false;
                case "trader_group_type"       : return false;
                case "instrument_name"         : return in.getInt(rowOffset + 36) < 0;
                case "instrument_symbol"       : return false;
                case "instrument_sector"       : return in.getInt(rowOffset + 44) < 0;
                case "instrument_industry"     : return in.getInt(rowOffset + 48) < 0;
                default : throw new UnsupportedOperationException(
                    String.format("Unknown column name '%s'.", _colName)
                );
            }
        }
    }
    
    @Override
    public void close() {
        
    }
}