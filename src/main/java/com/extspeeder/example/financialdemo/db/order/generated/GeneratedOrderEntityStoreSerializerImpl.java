package com.extspeeder.example.financialdemo.db.order.generated;

import com.extspeeder.example.financialdemo.db.order.Order;
import com.extspeeder.example.financialdemo.db.order.OrderImpl;
import com.extspeeder.example.financialdemo.extra.BuySell;
import com.extspeeder.example.financialdemo.extra.CohortType;
import com.extspeeder.example.financialdemo.extra.OrderType;
import com.extspeeder.example.financialdemo.extra.Status;
import com.speedment.enterprise.datastore.runtime.entitystore.EntityStoreSerializer;
import com.speedment.enterprise.datastore.runtime.entitystore.StringSelection;
import com.speedment.enterprise.datastore.runtime.util.SerializerUtil;
import com.speedment.runtime.config.identifier.ColumnIdentifier;
import com.speedment.runtime.core.util.OptionalUtil;
import com.speedment.runtime.field.Field;
import com.speedment.runtime.field.StringField;
import com.speedment.runtime.field.trait.HasBooleanValue;
import com.speedment.runtime.field.trait.HasByteValue;
import com.speedment.runtime.field.trait.HasCharValue;
import com.speedment.runtime.field.trait.HasDoubleValue;
import com.speedment.runtime.field.trait.HasFloatValue;
import com.speedment.runtime.field.trait.HasIntValue;
import com.speedment.runtime.field.trait.HasLongValue;
import com.speedment.runtime.field.trait.HasReferenceValue;
import com.speedment.runtime.field.trait.HasShortValue;
import java.math.BigDecimal;
import java.nio.BufferOverflowException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import javax.annotation.Generated;

/**
 * Serializes and deserializes instances of Order.
 * <p>
 * This file has been automatically generated by Speedment. Any changes made to
 * it will be overwritten.
 * <p>
 * The layout of the ByteBuffer:
 * <pre>
 * +--------+--------+------+--------------------+--------+------------------+
 * | Begin  | End    | Len  |               Name |  Usage |             Type |
 * +--------+--------+------+--------------------+--------+------------------+
 * |                      Constant Non-Nullable Fields                       |
 * +--------+--------+------+--------------------+--------+------------------+
 * | 0x0000 | 0x0000 | 0x01 |  trader_group_type |   data |       CohortType |
 * | 0x0001 | 0x0004 | 0x04 |              price |   data |            float |
 * | 0x0005 | 0x0006 | 0x02 |      date_executed |   data |            short |
 * | 0x0007 | 0x000E | 0x08 |                 id |   data |             long |
 * | 0x000F | 0x0010 | 0x02 |   date_created_int |   data |            short |
 * | 0x0011 | 0x0011 | 0x01 |          direction |   data |          BuySell |
 * | 0x0012 | 0x0012 | 0x01 |         order_type |   data |        OrderType |
 * | 0x0013 | 0x0016 | 0x04 |           quantity |   data |              int |
 * | 0x0017 | 0x0017 | 0x01 |             status |   data |           Status |
 * +--------+--------+------+--------------------+--------+------------------+
 * |                              End Positions                              |
 * +--------+--------+------+--------------------+--------+------------------+
 * | 0x001C | 0x001C | 0x01 |        limit_price | endpos |            Float |
 * | 0x001D | 0x0020 | 0x04 |  instrument_symbol | endpos |           String |
 * | 0x0021 | 0x0024 | 0x04 |  instrument_sector | endpos |           String |
 * | 0x0025 | 0x0028 | 0x04 | instrument_industry | endpos |           String |
 * | 0x0029 | 0x002C | 0x04 |        trader_name | endpos |           String |
 * | 0x002D | 0x0030 | 0x04 |       trader_group | endpos |           String |
 * | 0x0031 | 0x0034 | 0x04 |    instrument_name | endpos |           String |
 * +--------+--------+------+--------------------+--------+------------------+
 * |                               Row Storage                               |
 * +--------+--------+------+--------------------+--------+------------------+
 * |                 Constant Nullables and Variable Fields                  |
 * +--------+--------+------+--------------------+--------+------------------+
 * | 0x0035 | 0x7FFE | 0x00 | Variable data area |   data |           byte[] |
 * +--------+--------+------+--------------------+--------+------------------+
 * </pre>
 * <p>
 * Variable data area layout order:
 * limitPrice, instrumentSymbol, instrumentSector, instrumentIndustry,
 * traderName, traderGroup, instrumentName
 * 
 * @author Speedment
 */
@Generated("Speedment")
public class GeneratedOrderEntityStoreSerializerImpl implements EntityStoreSerializer<Order> {
    
    /**
     * Serializes and writes the trader_group_type of the orders to the
     * specified buffer.
     * 
     * @param out       the byte buffer to write to
     * @param rowOffset index where the row should start
     * @param value     value to serialize and write
     */
    protected void serializeTraderGroupType(ByteBuffer out, int rowOffset, CohortType value) {
        switch (value) {
            case BOSTON        : out.put(0 + rowOffset, (byte) 0); return;
            case WASHINGTON    : out.put(0 + rowOffset, (byte) 1); return;
            case NEW_YORK      : out.put(0 + rowOffset, (byte) 2); return;
            case QUANT_MODELS  : out.put(0 + rowOffset, (byte) 3); return;
            case SAN_FRANSISCO : out.put(0 + rowOffset, (byte) 4); return;
        }
        throw new IllegalStateException("Unexpected enum constant '" + value + "'.");
    }
    
    /**
     * Returns the trader_group_type of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the value starts
     * @return          the deserialized value
     */
    protected CohortType deserializeTraderGroupType(ByteBuffer in, int rowOffset) {
        switch (in.get(0 + rowOffset)) {
            case 0 : return CohortType.BOSTON;
            case 1 : return CohortType.WASHINGTON;
            case 2 : return CohortType.NEW_YORK;
            case 3 : return CohortType.QUANT_MODELS;
            case 4 : return CohortType.SAN_FRANSISCO;
        }
        throw new IllegalStateException("Unexpected CohortType ordinal in serialized data.");
    }
    
    /**
     * Serializes and writes the price of the orders to the specified buffer.
     * 
     * @param out       the byte buffer to write to
     * @param rowOffset index where the row should start
     * @param value     value to serialize and write
     */
    protected void serializePrice(ByteBuffer out, int rowOffset, float value) {
        out.putFloat(1 + rowOffset, value);
    }
    
    /**
     * Returns the price of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the value starts
     * @return          the deserialized value
     */
    protected float deserializePrice(ByteBuffer in, int rowOffset) {
        return in.getFloat(1 + rowOffset);
    }
    
    /**
     * Serializes and writes the date_executed of the orders to the specified
     * buffer.
     * 
     * @param out       the byte buffer to write to
     * @param rowOffset index where the row should start
     * @param value     value to serialize and write
     */
    protected void serializeDateExecuted(ByteBuffer out, int rowOffset, short value) {
        out.putShort(5 + rowOffset, value);
    }
    
    /**
     * Returns the date_executed of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the value starts
     * @return          the deserialized value
     */
    protected short deserializeDateExecuted(ByteBuffer in, int rowOffset) {
        return in.getShort(5 + rowOffset);
    }
    
    /**
     * Serializes and writes the id of the orders to the specified buffer.
     * 
     * @param out       the byte buffer to write to
     * @param rowOffset index where the row should start
     * @param value     value to serialize and write
     */
    protected void serializeId(ByteBuffer out, int rowOffset, long value) {
        out.putLong(7 + rowOffset, value);
    }
    
    /**
     * Returns the id of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the value starts
     * @return          the deserialized value
     */
    protected long deserializeId(ByteBuffer in, int rowOffset) {
        return in.getLong(7 + rowOffset);
    }
    
    /**
     * Serializes and writes the date_created_int of the orders to the specified
     * buffer.
     * 
     * @param out       the byte buffer to write to
     * @param rowOffset index where the row should start
     * @param value     value to serialize and write
     */
    protected void serializeDateCreated(ByteBuffer out, int rowOffset, short value) {
        out.putShort(15 + rowOffset, value);
    }
    
    /**
     * Returns the date_created_int of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the value starts
     * @return          the deserialized value
     */
    protected short deserializeDateCreated(ByteBuffer in, int rowOffset) {
        return in.getShort(15 + rowOffset);
    }
    
    /**
     * Serializes and writes the direction of the orders to the specified
     * buffer.
     * 
     * @param out       the byte buffer to write to
     * @param rowOffset index where the row should start
     * @param value     value to serialize and write
     */
    protected void serializeDirection(ByteBuffer out, int rowOffset, BuySell value) {
        switch (value) {
            case BUY  : out.put(17 + rowOffset, (byte) 0); return;
            case SELL : out.put(17 + rowOffset, (byte) 1); return;
        }
        throw new IllegalStateException("Unexpected enum constant '" + value + "'.");
    }
    
    /**
     * Returns the direction of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the value starts
     * @return          the deserialized value
     */
    protected BuySell deserializeDirection(ByteBuffer in, int rowOffset) {
        switch (in.get(17 + rowOffset)) {
            case 0 : return BuySell.BUY;
            case 1 : return BuySell.SELL;
        }
        throw new IllegalStateException("Unexpected BuySell ordinal in serialized data.");
    }
    
    /**
     * Serializes and writes the order_type of the orders to the specified
     * buffer.
     * 
     * @param out       the byte buffer to write to
     * @param rowOffset index where the row should start
     * @param value     value to serialize and write
     */
    protected void serializeOrderType(ByteBuffer out, int rowOffset, OrderType value) {
        switch (value) {
            case MARKET : out.put(18 + rowOffset, (byte) 0); return;
            case LIMIT  : out.put(18 + rowOffset, (byte) 1); return;
            case STOP   : out.put(18 + rowOffset, (byte) 2); return;
        }
        throw new IllegalStateException("Unexpected enum constant '" + value + "'.");
    }
    
    /**
     * Returns the order_type of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the value starts
     * @return          the deserialized value
     */
    protected OrderType deserializeOrderType(ByteBuffer in, int rowOffset) {
        switch (in.get(18 + rowOffset)) {
            case 0 : return OrderType.MARKET;
            case 1 : return OrderType.LIMIT;
            case 2 : return OrderType.STOP;
        }
        throw new IllegalStateException("Unexpected OrderType ordinal in serialized data.");
    }
    
    /**
     * Serializes and writes the quantity of the orders to the specified buffer.
     * 
     * @param out       the byte buffer to write to
     * @param rowOffset index where the row should start
     * @param value     value to serialize and write
     */
    protected void serializeQuantity(ByteBuffer out, int rowOffset, int value) {
        out.putInt(19 + rowOffset, value);
    }
    
    /**
     * Returns the quantity of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the value starts
     * @return          the deserialized value
     */
    protected int deserializeQuantity(ByteBuffer in, int rowOffset) {
        return in.getInt(19 + rowOffset);
    }
    
    /**
     * Serializes and writes the status of the orders to the specified buffer.
     * 
     * @param out       the byte buffer to write to
     * @param rowOffset index where the row should start
     * @param value     value to serialize and write
     */
    protected void serializeStatus(ByteBuffer out, int rowOffset, Status value) {
        switch (value) {
            case FILLED    : out.put(23 + rowOffset, (byte) 0); return;
            case CANCELLED : out.put(23 + rowOffset, (byte) 1); return;
            case EXPIRED   : out.put(23 + rowOffset, (byte) 2); return;
            case OPEN      : out.put(23 + rowOffset, (byte) 3); return;
            case REJECTED  : out.put(23 + rowOffset, (byte) 4); return;
        }
        throw new IllegalStateException("Unexpected enum constant '" + value + "'.");
    }
    
    /**
     * Returns the status of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the value starts
     * @return          the deserialized value
     */
    protected Status deserializeStatus(ByteBuffer in, int rowOffset) {
        switch (in.get(23 + rowOffset)) {
            case 0 : return Status.FILLED;
            case 1 : return Status.CANCELLED;
            case 2 : return Status.EXPIRED;
            case 3 : return Status.OPEN;
            case 4 : return Status.REJECTED;
        }
        throw new IllegalStateException("Unexpected Status ordinal in serialized data.");
    }
    
    /**
     * Serializes and writes the limit_price of the orders to the specified
     * buffer.
     * 
     * @param out          the byte buffer to write to
     * @param rowOffset    index where the row should start
     * @param begin        offset to the position for the particular column
     * @param endPosOffset offset to the position for the end index
     * @param value        value to serialize and write
     * @return             last index of the string (exclusive)
     */
    protected int serializeLimitPrice(
            ByteBuffer out,
            int rowOffset,
            int begin,
            int endPosOffset,
            Float value) {
        if (value == null) {
            out.put(rowOffset + endPosOffset, (byte)(-begin));
            return begin;
        } else {
            out.putFloat(begin + rowOffset, value);
            out.put(rowOffset + endPosOffset, (byte)(begin + 4));
            return begin + 4;
        }
    }
    
    /**
     * Returns the limit_price of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the value starts
     * @param end       last index of the value (exclusive). Negative if null.
     * @return          the deserialized value
     */
    protected Float deserializeLimitPrice(ByteBuffer in, int rowOffset, int end) {
        if (end < 0) {
            return null;
        } else {
            return in.getFloat(rowOffset + end - 4);
        }
    }
    
    /**
     * Serializes and writes the instrument_symbol of the orders to the
     * specified buffer, returning the index of the next value.
     * 
     * @param out          the byte buffer to write to
     * @param rowOffset    index in buffer where the row starts
     * @param begin        offset to the position for the particular column
     * @param endPosOffset offset to the position for the end index
     * @param value        the value to serialize
     * @return             last index of the string (exclusive)
     */
    protected int serializeInstrumentSymbol(
            ByteBuffer out,
            int rowOffset,
            int begin,
            int endPosOffset,
            String value) {
        return SerializerUtil.serializeByteArrayPutInt(out, rowOffset, begin, value.getBytes(StandardCharsets.UTF_8), endPosOffset);
    }
    
    /**
     * Returns the instrument_symbol of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected String deserializeInstrumentSymbol(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        return selectStringInstrumentSymbol(in, rowOffset, begin, end)
            .toString(StringSelection.Encoding.UTF_8);
    }
    
    /**
     * Serializes and writes the instrument_sector of the orders to the
     * specified buffer, returning the index of the next value.
     * 
     * @param out          the byte buffer to write to
     * @param rowOffset    index in buffer where the row starts
     * @param begin        offset to the position for the particular column
     * @param endPosOffset offset to the position for the end index
     * @param value        the value to serialize
     * @return             last index of the string (exclusive)
     */
    protected int serializeInstrumentSector(
            ByteBuffer out,
            int rowOffset,
            int begin,
            int endPosOffset,
            String value) {
        return SerializerUtil.serializeByteArrayPutInt(out, rowOffset, begin, value == null ? null : value.getBytes(StandardCharsets.UTF_8), endPosOffset);
    }
    
    /**
     * Returns the instrument_sector of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected String deserializeInstrumentSector(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        if (end < 0) {
            return null;
        } else {
            return selectStringInstrumentSector(in, rowOffset, begin, end)
                .toString(StringSelection.Encoding.UTF_8);
        }
    }
    
    /**
     * Serializes and writes the instrument_industry of the orders to the
     * specified buffer, returning the index of the next value.
     * 
     * @param out          the byte buffer to write to
     * @param rowOffset    index in buffer where the row starts
     * @param begin        offset to the position for the particular column
     * @param endPosOffset offset to the position for the end index
     * @param value        the value to serialize
     * @return             last index of the string (exclusive)
     */
    protected int serializeInstrumentIndustry(
            ByteBuffer out,
            int rowOffset,
            int begin,
            int endPosOffset,
            String value) {
        return SerializerUtil.serializeByteArrayPutInt(out, rowOffset, begin, value == null ? null : value.getBytes(StandardCharsets.UTF_8), endPosOffset);
    }
    
    /**
     * Returns the instrument_industry of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected String deserializeInstrumentIndustry(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        if (end < 0) {
            return null;
        } else {
            return selectStringInstrumentIndustry(in, rowOffset, begin, end)
                .toString(StringSelection.Encoding.UTF_8);
        }
    }
    
    /**
     * Serializes and writes the trader_name of the orders to the specified
     * buffer, returning the index of the next value.
     * 
     * @param out          the byte buffer to write to
     * @param rowOffset    index in buffer where the row starts
     * @param begin        offset to the position for the particular column
     * @param endPosOffset offset to the position for the end index
     * @param value        the value to serialize
     * @return             last index of the string (exclusive)
     */
    protected int serializeTraderName(
            ByteBuffer out,
            int rowOffset,
            int begin,
            int endPosOffset,
            String value) {
        return SerializerUtil.serializeByteArrayPutInt(out, rowOffset, begin, value.getBytes(StandardCharsets.UTF_8), endPosOffset);
    }
    
    /**
     * Returns the trader_name of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected String deserializeTraderName(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        return selectStringTraderName(in, rowOffset, begin, end)
            .toString(StringSelection.Encoding.UTF_8);
    }
    
    /**
     * Serializes and writes the trader_group of the orders to the specified
     * buffer, returning the index of the next value.
     * 
     * @param out          the byte buffer to write to
     * @param rowOffset    index in buffer where the row starts
     * @param begin        offset to the position for the particular column
     * @param endPosOffset offset to the position for the end index
     * @param value        the value to serialize
     * @return             last index of the string (exclusive)
     */
    protected int serializeTraderGroup(
            ByteBuffer out,
            int rowOffset,
            int begin,
            int endPosOffset,
            String value) {
        return SerializerUtil.serializeByteArrayPutInt(out, rowOffset, begin, value.getBytes(StandardCharsets.UTF_8), endPosOffset);
    }
    
    /**
     * Returns the trader_group of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected String deserializeTraderGroup(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        return selectStringTraderGroup(in, rowOffset, begin, end)
            .toString(StringSelection.Encoding.UTF_8);
    }
    
    /**
     * Serializes and writes the instrument_name of the orders to the specified
     * buffer, returning the index of the next value.
     * 
     * @param out          the byte buffer to write to
     * @param rowOffset    index in buffer where the row starts
     * @param begin        offset to the position for the particular column
     * @param endPosOffset offset to the position for the end index
     * @param value        the value to serialize
     * @return             last index of the string (exclusive)
     */
    protected int serializeInstrumentName(
            ByteBuffer out,
            int rowOffset,
            int begin,
            int endPosOffset,
            String value) {
        return SerializerUtil.serializeByteArrayPutInt(out, rowOffset, begin, value == null ? null : value.getBytes(StandardCharsets.UTF_8), endPosOffset);
    }
    
    /**
     * Returns the instrument_name of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected String deserializeInstrumentName(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        if (end < 0) {
            return null;
        } else {
            return selectStringInstrumentName(in, rowOffset, begin, end)
                .toString(StringSelection.Encoding.UTF_8);
        }
    }
    
    @Override
    public StringSelection selectString(ByteBuffer in, int rowOffset, StringField<Order, ?> field) {
        final ColumnIdentifier<Order> colId = field.identifier();
        if (colId instanceof Order.Identifier) {
            final Order.Identifier _id = (Order.Identifier) colId;
            switch (_id) {
                case INSTRUMENT_SYMBOL   : return selectStringInstrumentSymbol(in,     rowOffset, Math.abs(in.get(rowOffset + 28)),    in.getInt(rowOffset + 29));
                case INSTRUMENT_SECTOR   : return selectStringInstrumentSector(in,     rowOffset, Math.abs(in.getInt(rowOffset + 29)), in.getInt(rowOffset + 33));
                case INSTRUMENT_INDUSTRY : return selectStringInstrumentIndustry(in,   rowOffset, Math.abs(in.getInt(rowOffset + 33)), in.getInt(rowOffset + 37));
                case TRADER_NAME         : return selectStringTraderName(in,           rowOffset, Math.abs(in.getInt(rowOffset + 37)), in.getInt(rowOffset + 41));
                case TRADER_GROUP        : return selectStringTraderGroup(in,          rowOffset, Math.abs(in.getInt(rowOffset + 41)), in.getInt(rowOffset + 45));
                case INSTRUMENT_NAME     : return selectStringInstrumentName(in,       rowOffset, Math.abs(in.getInt(rowOffset + 45)), in.getInt(rowOffset + 49));
                default : throw new UnsupportedOperationException(
                    String.format("Unknown enum constant '%s'.", _id)
                );
            }
        } else {
            final String _colName = colId.getColumnName();
            switch (_colName) {
                case "instrument_symbol"   : return selectStringInstrumentSymbol(in,   rowOffset, Math.abs(in.get(rowOffset + 28)),    in.getInt(rowOffset + 29));
                case "instrument_sector"   : return selectStringInstrumentSector(in,   rowOffset, Math.abs(in.getInt(rowOffset + 29)), in.getInt(rowOffset + 33));
                case "instrument_industry" : return selectStringInstrumentIndustry(in, rowOffset, Math.abs(in.getInt(rowOffset + 33)), in.getInt(rowOffset + 37));
                case "trader_name"         : return selectStringTraderName(in,         rowOffset, Math.abs(in.getInt(rowOffset + 37)), in.getInt(rowOffset + 41));
                case "trader_group"        : return selectStringTraderGroup(in,        rowOffset, Math.abs(in.getInt(rowOffset + 41)), in.getInt(rowOffset + 45));
                case "instrument_name"     : return selectStringInstrumentName(in,     rowOffset, Math.abs(in.getInt(rowOffset + 45)), in.getInt(rowOffset + 49));
                default : throw new UnsupportedOperationException(
                    String.format("Unknown column name '%s'.", _colName)
                );
            }
        }
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public <T> T deserializeReference(ByteBuffer in, int rowOffset, HasReferenceValue<Order, ?, T> field) {
        final ColumnIdentifier<Order> colId = field.identifier();
        if (colId instanceof Order.Identifier) {
            final Order.Identifier _id = (Order.Identifier) colId;
            switch (_id) {
                case TRADER_GROUP_TYPE   : return (T) deserializeTraderGroupType(in,      rowOffset);
                case DIRECTION           : return (T) deserializeDirection(in,            rowOffset);
                case ORDER_TYPE          : return (T) deserializeOrderType(in,            rowOffset);
                case STATUS              : return (T) deserializeStatus(in,               rowOffset);
                case LIMIT_PRICE         : return (T) deserializeLimitPrice(in,           rowOffset, in.get(rowOffset + 28));
                case INSTRUMENT_SYMBOL   : return (T) deserializeInstrumentSymbol(in,     rowOffset, Math.abs(in.get(rowOffset + 28)),    in.getInt(rowOffset + 29));
                case INSTRUMENT_SECTOR   : return (T) deserializeInstrumentSector(in,     rowOffset, Math.abs(in.getInt(rowOffset + 29)), in.getInt(rowOffset + 33));
                case INSTRUMENT_INDUSTRY : return (T) deserializeInstrumentIndustry(in,   rowOffset, Math.abs(in.getInt(rowOffset + 33)), in.getInt(rowOffset + 37));
                case TRADER_NAME         : return (T) deserializeTraderName(in,           rowOffset, Math.abs(in.getInt(rowOffset + 37)), in.getInt(rowOffset + 41));
                case TRADER_GROUP        : return (T) deserializeTraderGroup(in,          rowOffset, Math.abs(in.getInt(rowOffset + 41)), in.getInt(rowOffset + 45));
                case INSTRUMENT_NAME     : return (T) deserializeInstrumentName(in,       rowOffset, Math.abs(in.getInt(rowOffset + 45)), in.getInt(rowOffset + 49));
                default : throw new UnsupportedOperationException(
                    String.format("Unknown enum constant '%s'.", _id)
                );
            }
        } else {
            final String _colName = colId.getColumnName();
            switch (_colName) {
                case "trader_group_type"   : return (T) deserializeTraderGroupType(in,    rowOffset);
                case "direction"           : return (T) deserializeDirection(in,          rowOffset);
                case "order_type"          : return (T) deserializeOrderType(in,          rowOffset);
                case "status"              : return (T) deserializeStatus(in,             rowOffset);
                case "limit_price"         : return (T) deserializeLimitPrice(in,         rowOffset, in.get(rowOffset + 28));
                case "instrument_symbol"   : return (T) deserializeInstrumentSymbol(in,   rowOffset, Math.abs(in.get(rowOffset + 28)),    in.getInt(rowOffset + 29));
                case "instrument_sector"   : return (T) deserializeInstrumentSector(in,   rowOffset, Math.abs(in.getInt(rowOffset + 29)), in.getInt(rowOffset + 33));
                case "instrument_industry" : return (T) deserializeInstrumentIndustry(in, rowOffset, Math.abs(in.getInt(rowOffset + 33)), in.getInt(rowOffset + 37));
                case "trader_name"         : return (T) deserializeTraderName(in,         rowOffset, Math.abs(in.getInt(rowOffset + 37)), in.getInt(rowOffset + 41));
                case "trader_group"        : return (T) deserializeTraderGroup(in,        rowOffset, Math.abs(in.getInt(rowOffset + 41)), in.getInt(rowOffset + 45));
                case "instrument_name"     : return (T) deserializeInstrumentName(in,     rowOffset, Math.abs(in.getInt(rowOffset + 45)), in.getInt(rowOffset + 49));
                default : throw new UnsupportedOperationException(
                    String.format("Unknown column name '%s'.", _colName)
                );
            }
        }
    }
    
    @Override
    public boolean deserializeBoolean(ByteBuffer in, int rowOffset, HasBooleanValue<Order, ?> field) {
        final ColumnIdentifier<Order> colId = field.identifier();
        throw new UnsupportedOperationException(
            String.format("Unknown enum constant '%s'.", colId.getColumnName())
        );
    }
    
    @Override
    public byte deserializeByte(ByteBuffer in, int rowOffset, HasByteValue<Order, ?> field) {
        final ColumnIdentifier<Order> colId = field.identifier();
        throw new UnsupportedOperationException(
            String.format("Unknown enum constant '%s'.", colId.getColumnName())
        );
    }
    
    @Override
    public double deserializeDouble(ByteBuffer in, int rowOffset, HasDoubleValue<Order, ?> field) {
        final ColumnIdentifier<Order> colId = field.identifier();
        throw new UnsupportedOperationException(
            String.format("Unknown enum constant '%s'.", colId.getColumnName())
        );
    }
    
    @Override
    public char deserializeChar(ByteBuffer in, int rowOffset, HasCharValue<Order, ?> field) {
        final ColumnIdentifier<Order> colId = field.identifier();
        throw new UnsupportedOperationException(
            String.format("Unknown enum constant '%s'.", colId.getColumnName())
        );
    }
    
    @Override
    public short deserializeShort(ByteBuffer in, int rowOffset, HasShortValue<Order, ?> field) {
        final ColumnIdentifier<Order> colId = field.identifier();
        if (colId instanceof Order.Identifier) {
            final Order.Identifier _id = (Order.Identifier) colId;
            switch (_id) {
                case DATE_EXECUTED : return deserializeDateExecuted(in,      rowOffset);
                case DATE_CREATED  : return deserializeDateCreated(in,       rowOffset);
                default : throw new UnsupportedOperationException(
                    String.format("Unknown enum constant '%s'.", _id)
                );
            }
        } else {
            final String _colName = colId.getColumnName();
            switch (_colName) {
                case "date_executed"    : return deserializeDateExecuted(in, rowOffset);
                case "date_created_int" : return deserializeDateCreated(in,  rowOffset);
                default : throw new UnsupportedOperationException(
                    String.format("Unknown column name '%s'.", _colName)
                );
            }
        }
    }
    
    @Override
    public float deserializeFloat(ByteBuffer in, int rowOffset, HasFloatValue<Order, ?> field) {
        final ColumnIdentifier<Order> colId = field.identifier();
        if ("price".equals(colId.getColumnName())) {
            return deserializePrice(in, rowOffset);
        }
        
        throw new UnsupportedOperationException(
            String.format("Unknown column '%s'.", colId)
        );
    }
    
    @Override
    public int deserializeInt(ByteBuffer in, int rowOffset, HasIntValue<Order, ?> field) {
        final ColumnIdentifier<Order> colId = field.identifier();
        if ("quantity".equals(colId.getColumnName())) {
            return deserializeQuantity(in, rowOffset);
        }
        
        throw new UnsupportedOperationException(
            String.format("Unknown column '%s'.", colId)
        );
    }
    
    @Override
    public long deserializeLong(ByteBuffer in, int rowOffset, HasLongValue<Order, ?> field) {
        final ColumnIdentifier<Order> colId = field.identifier();
        if ("id".equals(colId.getColumnName())) {
            return deserializeId(in, rowOffset);
        }
        
        throw new UnsupportedOperationException(
            String.format("Unknown column '%s'.", colId)
        );
    }
    
    @Override
    public Order deserialize(ByteBuffer in, int rowOffset) {
        final int limitPriceEnd         = in.get(rowOffset + 28);
        final int instrumentSymbolEnd   = in.getInt(rowOffset + 29);
        final int instrumentSectorEnd   = in.getInt(rowOffset + 33);
        final int instrumentIndustryEnd = in.getInt(rowOffset + 37);
        final int traderNameEnd         = in.getInt(rowOffset + 41);
        final int traderGroupEnd        = in.getInt(rowOffset + 45);
        final int instrumentNameEnd     = in.getInt(rowOffset + 49);
        
        final Order entity = newEntity();
        entity.setTraderGroupType(deserializeTraderGroupType(in, rowOffset));
        entity.setPrice(deserializePrice(in, rowOffset));
        entity.setDateExecuted(deserializeDateExecuted(in, rowOffset));
        entity.setId(deserializeId(in, rowOffset));
        entity.setDateCreated(deserializeDateCreated(in, rowOffset));
        entity.setDirection(deserializeDirection(in, rowOffset));
        entity.setOrderType(deserializeOrderType(in, rowOffset));
        entity.setQuantity(deserializeQuantity(in, rowOffset));
        entity.setStatus(deserializeStatus(in, rowOffset));
        entity.setLimitPrice(deserializeLimitPrice(in, rowOffset, limitPriceEnd));
        entity.setInstrumentSymbol(deserializeInstrumentSymbol(in, rowOffset, Math.abs(limitPriceEnd), instrumentSymbolEnd));
        entity.setInstrumentSector(deserializeInstrumentSector(in, rowOffset, Math.abs(instrumentSymbolEnd), instrumentSectorEnd));
        entity.setInstrumentIndustry(deserializeInstrumentIndustry(in, rowOffset, Math.abs(instrumentSectorEnd), instrumentIndustryEnd));
        entity.setTraderName(deserializeTraderName(in, rowOffset, Math.abs(instrumentIndustryEnd), traderNameEnd));
        entity.setTraderGroup(deserializeTraderGroup(in, rowOffset, Math.abs(traderNameEnd), traderGroupEnd));
        entity.setInstrumentName(deserializeInstrumentName(in, rowOffset, Math.abs(traderGroupEnd), instrumentNameEnd));
        return entity;
    }
    
    @Override
    public int serialize(ByteBuffer out, int rowOffset, Order entity) throws BufferOverflowException {
        int startPos = 53;
        
        serializeTraderGroupType(out, rowOffset, entity.getTraderGroupType());
        serializePrice(out, rowOffset, entity.getPrice());
        serializeDateExecuted(out, rowOffset, entity.getDateExecuted());
        serializeId(out, rowOffset, entity.getId());
        serializeDateCreated(out, rowOffset, entity.getDateCreated());
        serializeDirection(out, rowOffset, entity.getDirection());
        serializeOrderType(out, rowOffset, entity.getOrderType());
        serializeQuantity(out, rowOffset, entity.getQuantity());
        serializeStatus(out, rowOffset, entity.getStatus());
        startPos = serializeLimitPrice(out, rowOffset, startPos, 28, entity.getLimitPrice());
        startPos = serializeInstrumentSymbol(out, rowOffset, startPos, 29, entity.getInstrumentSymbol());
        startPos = serializeInstrumentSector(out, rowOffset, startPos, 33, OptionalUtil.unwrap(entity.getInstrumentSector()));
        startPos = serializeInstrumentIndustry(out, rowOffset, startPos, 37, OptionalUtil.unwrap(entity.getInstrumentIndustry()));
        startPos = serializeTraderName(out, rowOffset, startPos, 41, entity.getTraderName());
        startPos = serializeTraderGroup(out, rowOffset, startPos, 45, entity.getTraderGroup());
        startPos = serializeInstrumentName(out, rowOffset, startPos, 49, OptionalUtil.unwrap(entity.getInstrumentName()));
        return startPos;
    }
    
    protected Order newEntity() {
        return new OrderImpl();
    }
    
    /**
     * Returns a selection of the instrument_symbol of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected StringSelection selectStringInstrumentSymbol(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        final int len = end - begin;
        return StringSelection.create(in, rowOffset + begin, len);
    }
    
    /**
     * Returns a selection of the instrument_sector of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected StringSelection selectStringInstrumentSector(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        final int len = end - begin;
        return StringSelection.create(in, rowOffset + begin, len);
    }
    
    /**
     * Returns a selection of the instrument_industry of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected StringSelection selectStringInstrumentIndustry(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        final int len = end - begin;
        return StringSelection.create(in, rowOffset + begin, len);
    }
    
    /**
     * Returns a selection of the trader_name of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected StringSelection selectStringTraderName(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        final int len = end - begin;
        return StringSelection.create(in, rowOffset + begin, len);
    }
    
    /**
     * Returns a selection of the trader_group of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected StringSelection selectStringTraderGroup(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        final int len = end - begin;
        return StringSelection.create(in, rowOffset + begin, len);
    }
    
    /**
     * Returns a selection of the instrument_name of the orders.
     * 
     * @param in        the byte buffer to read from
     * @param rowOffset index in buffer where the row starts
     * @param begin     where in the row the field begins
     * @param end       where in the row the field ends (exclusive)
     * @return          the deserialized value
     */
    protected StringSelection selectStringInstrumentName(
            ByteBuffer in,
            int rowOffset,
            int begin,
            int end) {
        final int len = end - begin;
        return StringSelection.create(in, rowOffset + begin, len);
    }
    
    @Override
    public boolean isNull(ByteBuffer in, int rowOffset, Field<Order> field) {
        final ColumnIdentifier<Order> colId = field.identifier();
        if (colId instanceof Order.Identifier) {
            final Order.Identifier _id = (Order.Identifier) colId;
            switch (_id) {
                case TRADER_GROUP_TYPE   : return false;
                case PRICE               : return false;
                case DATE_EXECUTED       : return false;
                case ID                  : return false;
                case DATE_CREATED        : return false;
                case DIRECTION           : return false;
                case ORDER_TYPE          : return false;
                case QUANTITY            : return false;
                case STATUS              : return false;
                case LIMIT_PRICE         : return in.getInt(rowOffset + 28) < 0;
                case INSTRUMENT_SYMBOL   : return false;
                case INSTRUMENT_SECTOR   : return in.getInt(rowOffset + 33) < 0;
                case INSTRUMENT_INDUSTRY : return in.getInt(rowOffset + 37) < 0;
                case TRADER_NAME         : return false;
                case TRADER_GROUP        : return false;
                case INSTRUMENT_NAME     : return in.getInt(rowOffset + 49) < 0;
                default : throw new UnsupportedOperationException(
                    String.format("Unknown enum constant '%s'.", _id)
                );
            }
        } else {
            final String _colName = colId.getColumnName();
            switch (_colName) {
                case "trader_group_type"   : return false;
                case "price"               : return false;
                case "date_executed"       : return false;
                case "id"                  : return false;
                case "date_created_int"    : return false;
                case "direction"           : return false;
                case "order_type"          : return false;
                case "quantity"            : return false;
                case "status"              : return false;
                case "limit_price"         : return in.getInt(rowOffset + 28) < 0;
                case "instrument_symbol"   : return false;
                case "instrument_sector"   : return in.getInt(rowOffset + 33) < 0;
                case "instrument_industry" : return in.getInt(rowOffset + 37) < 0;
                case "trader_name"         : return false;
                case "trader_group"        : return false;
                case "instrument_name"     : return in.getInt(rowOffset + 49) < 0;
                default : throw new UnsupportedOperationException(
                    String.format("Unknown column name '%s'.", _colName)
                );
            }
        }
    }
    
    @Override
    public void close() {
        
    }
}