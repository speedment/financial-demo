package com.extspeeder.example.financialdemo.financialdemo.db.piq.order.generated;

import com.extspeeder.example.financialdemo.extra.BuySell;
import com.extspeeder.example.financialdemo.extra.OrderType;
import com.extspeeder.example.financialdemo.extra.Status;
import com.extspeeder.example.financialdemo.financialdemo.db.piq.order.Order;
import com.speedment.enterprise.core.util.BitSetUtil;
import com.speedment.enterprise.offheapreadonlycache.entity.AbstractEntitySerializer;
import com.speedment.enterprise.offheapreadonlycache.internal.serializer.SerializerFactory;
import com.speedment.manager.Manager;
import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import javax.annotation.Generated;
import org.mapdb.Serializer;

/**
 * A {@link org.mapdb.Serializer} class for table {@link
 * com.speedment.config.db.Table} named orders.
 * <p>
 * This file has been automatically generated by Ext Speeder. Any changes
 * made to it will be overwritten.
 * 
 * @author Speedment
 */
@Generated("Ext Speeder")
public class GeneratedOrderSerializerImpl extends AbstractEntitySerializer<Order> {
    
    protected final static long serialVersionUID = 272500689;
    private final static Serializer<Long> ID_SERIALIZER = SerializerFactory.serializerOf(Long.class);
    private final static Serializer<Integer> DATE_CREATED_SERIALIZER = SerializerFactory.serializerOf(Integer.class);
    private final static Serializer<BuySell> DIRECTION_SERIALIZER = SerializerFactory.serializerOf(BuySell.class);
    private final static Serializer<OrderType> ORDER_TYPE_SERIALIZER = SerializerFactory.serializerOf(OrderType.class);
    private final static Serializer<Integer> QUANTITY_SERIALIZER = SerializerFactory.serializerOf(Integer.class);
    private final static Serializer<Status> STATUS_SERIALIZER = SerializerFactory.serializerOf(Status.class);
    private final static Serializer<Double> LIMIT_PRICE_SERIALIZER = SerializerFactory.serializerOf(Double.class);
    private final static Serializer<String> INSTRUMENT_SYMBOL = SerializerFactory.serializerOf(String.class);
    private final static Serializer<String> INSTRUMENT_SECTOR = SerializerFactory.serializerOf(String.class);
    private final static Serializer<String> INSTRUMENT_INDUSTRY = SerializerFactory.serializerOf(String.class);
    private final static Serializer<String> TRADER_NAME = SerializerFactory.serializerOf(String.class);
    private final static Serializer<String> TRADER_GROUP = SerializerFactory.serializerOf(String.class);
    private final static Serializer<String> TRADER_GROUP_TYPE = SerializerFactory.serializerOf(String.class);
    private final static Serializer<Double> PRICE = SerializerFactory.serializerOf(Double.class);
    private final static Serializer<Integer> DATE_EXECUTED = SerializerFactory.serializerOf(Integer.class);
    
    public GeneratedOrderSerializerImpl(Manager<Order> manager) {
        super(manager);
    }
    
    @Override
    public void serialize(final DataOutput out, final Order order) throws IOException {
        final long[] bits = new long[1];
        if (!order.getLimitPrice().isPresent()) BitSetUtil.set(bits, 0);
        if (!order.getInstrumentSector().isPresent()) BitSetUtil.set(bits, 1);
        if (!order.getInstrumentIndustry().isPresent()) BitSetUtil.set(bits, 2);
        if (order.getPrice() == null) BitSetUtil.set(bits, 3);
        if (order.getDateExecuted() == null) BitSetUtil.set(bits, 4);
        out.writeLong(bits[0]);
        out.writeLong(order.getId());
        out.writeInt(order.getDateCreated());
        DIRECTION_SERIALIZER.serialize(out, order.getDirection());
        ORDER_TYPE_SERIALIZER.serialize(out, order.getOrderType());
        out.writeInt(order.getQuantity());
        STATUS_SERIALIZER.serialize(out, order.getStatus());
        if (order.getLimitPrice().isPresent()) out.writeDouble(order.getLimitPrice().get());
        out.writeUTF(order.getInstrumentSymbol());
        if (order.getInstrumentSector().isPresent()) out.writeUTF(order.getInstrumentSector().get());
        if (order.getInstrumentIndustry().isPresent()) out.writeUTF(order.getInstrumentIndustry().get());
        out.writeUTF(order.getTraderName());
        out.writeUTF(order.getTraderGroup());
        out.writeUTF(order.getTraderGroupType());
        if (order.getPrice() != null) out.writeDouble(order.getPrice());
        if (order.getDateExecuted()  != null) out.writeInt(order.getDateExecuted());
    }
    
    @Override
    public Order deserialize(final DataInput in, final int available) throws IOException {
        final Order order = manager.newEmptyEntity();
        final long[] bits = new long[1];
        bits[0] = in.readLong();
        order.setId(in.readLong());
        order.setDateCreated(in.readInt());
        order.setDirection(DIRECTION_SERIALIZER.deserialize(in, available));
        order.setOrderType(ORDER_TYPE_SERIALIZER.deserialize(in, available));
        order.setQuantity(in.readInt());
        order.setStatus(STATUS_SERIALIZER.deserialize(in, available));
        if (!BitSetUtil.get0(bits)) order.setLimitPrice(in.readDouble());
        order.setInstrumentSymbol(in.readUTF());
        if (!BitSetUtil.get1(bits)) order.setInstrumentSector(in.readUTF());
        if (!BitSetUtil.get2(bits)) order.setInstrumentIndustry(in.readUTF());
        order.setTraderName(in.readUTF());
        order.setTraderGroup(in.readUTF());
        order.setTraderGroupType(in.readUTF());
        if (!BitSetUtil.get3(bits)) order.setPrice(in.readDouble());
        if (!BitSetUtil.get4(bits)) order.setDateExecuted(in.readInt());
        return order;
    }
}